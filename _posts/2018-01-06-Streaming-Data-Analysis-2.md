---
layout: post
title: 流数据聚类分析(2)：CluStream 算法
category: Machine Learning
author: Hongtao Yu
tags: 
  - machine-learning
  - data-streaming
comments: true
use_math: true
lang: zh
---

- TOC
{:toc}

# 概述

`CluStream 流数据聚类算法` 由 Aggarwal 等人在 2003 年提出。算法借用并扩展了 `BRICH 聚类算法`（Balanced Iterative Reducing and Clustering using Hierarchies）中的`簇特征矢量`（Cluster Feature Vector）。并利用簇特征矢量的可加性和可减性，以达到对不同时间颗粒度聚类的需求。CluStream 算法开创性地提出了流数据的两阶段处理框架。它将聚类过程分为两部分：在线的`微聚类`（micro-clustering）以及离线的`宏聚类`（macro-clustering）。该两阶段框架被许多后来的流数据聚类算法，包括我们之前讨论的 `DenStream 流数据聚类算法`，所采用。

# 流数据聚类时间框架

这里的流数据聚类两阶段框架被称为 `CluStream 框架`。将流数据聚类分为在线和离线部分需要考虑以下几个问题：

1. 聚类的概要信息要能有效地存储数据流的时间和空间信息，以满足离线聚类过程的不同视野需求。

2. 聚类概要信息的持久化存储频率一方面要考虑存储空间的限制，另一方面又可以在一定的近似水平上满足不同时间颗粒度的聚类需求。

3. 周期性存储的聚类统计信息要能给出用户指定的时间视野内的数据流的聚类和演化信息。

CluStream 框架利用 `微簇`（Micro-clusters）和`金字塔式时间框`（Pyramidal Time Frame）解决了上述问题。其中微簇的定义使用扩展的簇特征矢量。簇特征矢量的可加和性使其成为流数据聚类的自然选择。金字塔式时间框可以在存储空间需求和视野颗粒度需求之间达到一个有效的折衷。

假定流数据为一系列不断到来的 $d$ 维数据集 $X_1, X_2, \cdots, X_k, \cdots $, $X_k = (x_k^1, x_k^2, \cdots, x_k^d)$。每个数据对应一个时间戳 $T_1, T_2, \cdots, T_k, \cdots$。

## 微簇

**定义：** 对于一系列 $d$ 维数据点 $X_{i_1}, X_{i_2}, \cdots, X_{i_n}$，对应的时间戳为 $T_{i_1}, T_{i_2}, \cdots, T_{i_n}$。 微簇表示为一个长度为 $2\times d + 3$ 的元组 $(\overline{CF2^x}, \overline{CF1^x}, \overline{CF2^t}, \overline{CF1^t}, n)$，其中：
   - $\overline{CF2^x}$ 为一个 $d$ 维矢量，其中每一个维度的值为数据点对应维度值的平方和。比如 $\overline{CF2^x}$ 的第 $p$ 维的值为 $\sum_{j=1}^n(x_{i_j}^p)^2$。

   - $\overline{CF1^x}$ 为一个 $d$ 维矢量，其中每一个维度的值为数据点对应维度值的和。比如 $\overline{CF1^x}$ 的第 $p$ 维的值为 $\sum_{j=1}^n x_{i_j}^p$。

   - $\overline{CF2^t}$ 为一个标量，其值为数据点对应时间戳的平方和 $\sum_{j=1}^n(T_{i_j})^2$。

   - $\overline{CF1^t}$ 为一个标量，其值为数据点对应时间戳的和 $\sum_{j=1}^n T_{i_j}$。

   - $n$ 为微簇内包含的数据点个数。

接下来我们记数据集 $\mathcal{C}$ 形成的微簇为 $\overline{CFC}(\mathcal{C})$。通过该方式定义的簇特征矢量满足`可加性`和`可减性`。


微簇在一些特定的时间点被存储起来，被称为`快照`（snapshots）。离线阶段通过对这些微簇聚类，形成特定时间视野内的更高层次的簇。例如，假定当前时间为 $t_c$， 用户想要得到过去 $h$ 时间段内的数据聚类信息。算法首先找到 $t_c$ 和 $t_c - h$ 时刻的快照，然后利用簇特征矢量的可减性，得到视野长度 $h$ 内的微簇，然后通过聚类这些微簇得到更高层次的簇。

实践中，由于存储空间的限制，我们不可能保存所有时刻的快照。所以需要制定一个存储策略，以便当用户指定某个时间视野 ($t_c-h, t_c$)时，算法能给出一个可以接受的近似。


## 金字塔式时间框

为了满足不同时间视野的聚类需求，快照在不同的粒度等级下被存储。并且一个粒度等级只存储最近的几个快照。

- 第 $i$ 级快照只在 $\alpha^i$ ($\alpha \geq 1$ 且为整数) 时刻被存储。例如，当 $T=8$, $\alpha = 2$ ，快照的存储时刻为：
    
    - 0 级快照（$2^0$ 间隔）：0， 1， 2， 3 ，4 ，5 ，6， 7， 8。
    - 1 级快照（$2^1$ 间隔）：0， 2， 4， 6， 8。
    - 2 级快照（$2^2$ 间隔）：0， 4， 8。
    - 3 级快照（$2^3$ 间隔）：0， 8。

- 每个等级只存储 $\alpha + 1$ 个最近的快照。例如，因为上例中 $\alpha + 1 = 3$，所以有：

    - 0 级快照（$2^0$ 间隔）：6， 7， 8。
    - 1 级快照（$2^1$ 间隔）：4， 6， 8。
    - 2 级快照（$2^2$ 间隔）：0， 4， 8。
    - 3 级快照（$2^3$ 间隔）：0， 8。


假定从数据流开始到当前时刻流逝的时间为 $T$，那么有：

- 存储的快照的最大等级为 $\log_{\alpha}(T)$。

- 存储的快照的最大个数为 $(\alpha + 1)\cdot \log_{\alpha}(T)$。

- 对用户指定的任意时间窗口 $h$, 至少有一个快照可以在离当前时刻 $2h$ 的范围内被找到（详细证明见文献 1 的 **Lemma 1**）。 

考虑 $\alpha = 2$, 如果数据以 1 秒的颗粒度存储，那么100 年的数据需要的存储空间为 $(2 + 1) \times \log_2 (100 \times 365 \times 24 \times 60 \times 60) \approx 95$。


算法的精度可以通过保留更多的快照（比如 $\alpha ^ l + 1$ 个）来提高。这时需要的存储空间为 $(\alpha ^ l + 1) \log_{\alpha}(T)$，这时，对时间窗口 $h$, 至少有一个快照可以在离当前时刻 $(1 + 1/\alpha^{l-1})h$ 的范围内被找到。如果取 $\alpha = 2, l=10$，那么存储 100 年的数据需要的空间为$(2^{10} + 1) \times \log_2 (100 \times 365 \times 24 \times 60 \times 60) \approx 32343$。

使用上述策略保存的快照有可能是冗余的。考虑 $\alpha = 2, l=2, T=55$ 的例子。每个等级有 $2^2 + 1 = 5$ 个快照被存储起来。下表显示了不同等级下被保存的快照

| 快照级别  |      存储快照的时刻       |
|:-----:|:----------------:|
| 0     | 55 ~~54~~ 53 ~~52~~ 51|
| 1     | 54 ~~52~~ 50 ~~48~~ 46|
| 2     | 52 ~~48~~ 44 ~~40~~ 36|
| 3     | ~~48~~ 40 ~~32~~ 24 ~~16~~|
| 4     | 48 ~~32~~ 16|
| 5     | 32 |

**Table 2-1.** $\alpha = 2, l=2, T=55$ 的例子。

上表中删除线划出的为冗余的快照时间。其中 0 级快照能被 2 整除的时刻的快照为冗余的，1 级快照能被 4 整除的时刻的快照为冗余的。总的来说 $l$ 级快照能被 $2^{l+1}$ 整除的时刻的快照为冗余的快照。所以一个快照产生的时候，需要进行以下两个操作：

1. 如果一个快照是冗余的，那么就可以不用产生。

2. 如果快照的数量已经超过了最大限制，那么产生一个新快照的时候就需要删除一个旧的快照。具体的策略将在下面讨论。

# 在线微簇维护

假定算法在任何时刻需要维护 $q$ 个微簇，记为 $\mathcal{M}_1, \cdots, \mathcal{M}_q$。其中每个微簇在创建时刻被分配一个唯一的 ID。如果需要合并两个微簇，那么使用这两个簇的 ID 创建一个列表，这个列表将会被用来做减量操作以获取任意时间段内的聚类信息。微簇个数 $q$ 由内存的限制决定。在每个可以被 $\alpha^i$ 整除的时刻，快照存储的微簇信息被持久化到硬盘。 如果某个级别 $l$ 的快照个数超过了限制，那么创建时间早于 $\alpha^{l+r}$ 的快照将被从硬盘删除。


假定数据流开始前我们已经有 $InitNum$ 个数据，那么首先使用 `k-means 算法` 创建 $q$ 个微簇。
数据流开始后，一旦有一个新的数据点 $X_{i_k}$ 进来，那么新的数据点将会尝试被一个距离它最近的微簇吸收。如果该数据点不能被任何微簇吸收，那么就创建一个新的微簇，并分配一个唯一的 ID。


## 新簇的创建

一个数据点 $X_{i_k}$ 不能被现有的任何微簇吸收分两种情况：

1. $X_{i_k}$ 是一个离群点。

2. $X_{i_k}$ 是一个新簇的开始。

那么怎么判断一个数据点能否被现有的微簇吸收呢？对于一个微簇 $\mathcal{M}_p$，我们可以利用它的簇特征矢量定义 $\mathcal{M}_p$ 的`最大边界`（maximum boundary）。最大边界定义为微簇内数据点的`方均根差`（RMS deviation, RMSd）与一个因子 $t$ 的乘积。如果一个数据点离微簇 $\mathcal{M}_p$ 的距离小于 $\mathcal{M}_p$ 的最大边界，那么就可以被该微簇吸收。

> 需要注意的是 RMSd 的定义只对包含多个数据点的微簇有效，如果一个微簇只包含一个数据点，那么取离它最近的微簇的距离作为 RMSd。
 
## 离群微簇的删除与微簇的合并
 
如果一个数据点不能被任何微簇吸收，那么就需要根据该数据点创建一个新的微簇，同时要么删除一个离群簇，要么合并两个非离群微簇。CluStream 算法首先在维护的微簇里寻找离群簇，如果有，则删除一个离群簇，否则，则合并两个微簇。


### 离群微簇的删除

不能简单地以一个微簇中包含的数据点个数来判断一个微簇是否是离群微簇。因为可能一个微簇刚开始生长，还没有足够的数据点到达。一个合理的判断离群微簇的方法是估计微簇内最近到达的 $m$ 个数据点的平均到达时间 $t_m$, 然后删除最久没有更新的微簇。但是问题是，由于内存的限制，我们并没有存储最近到达的 $m$ 个数据点的时间戳。所以我们只能近似的估计。

由于微簇的簇特征矢量包含了簇内所有数据点到达时间的和以及时间的平方和，所以我们可以计算一个簇 $\mathcal{M}$ 中数据点的平均到达时间 $\mu_{\mathcal{M}}$ 以及到达时间的标准差（Standard Devision）$\sigma_{\mathcal{M}}$。在计算中我们假定数据的到达时间服从正态分布。那么就可以使用第 $m/(2n)$ 个到达时间作为 $t_m$ 的一个近似估计。这个时间被称为微簇 $\mathcal{M}$ 的相关时间戳（relevance stamp）。如果一个微簇的相关时间戳小于某个定义的阈值 $\delta$，那么该簇就被认为是一个离群微簇，可以删除。

### 微簇的合并

如果通过前述方法找不到任何离群微簇，那么就需要合并两个微簇，以减少内存的需求。合并后的微簇不再具有一个唯一的 ID，而是一个包含两个微簇 ID 的列表。所以通过一个微簇的 ID 长度可以判断该簇是不是由其他微簇合并而来。


## 微簇的存储

上边的过程是在一个新数据到达的情况下进行的操作。在每一个  $\alpha^i$ 时刻, 我们需要将微簇以及其对应的 ID （或 ID 列表）存储到硬盘。存储时，如果第 $i$ 级的快照个数超过了 $\alpha^l + 1$, 我们需要将最早存储的快照（同时需要保证该快照的存储时间不能被 $\alpha^{i+1}$ 整除）移除。


# 离线宏簇生成

假定某个时刻，用户需要取得时间视野  $h$ 内的聚类结果，需要将流数据聚类为 $k$ 个簇。由于每个时间快照保存的是从流数据开始到快照时刻所有数据形成的微簇。为了取得特定时间段内的微簇，以便生成 $k$ 个宏簇，我们需要利用微簇的以下两个性质：

**性质 1：** 令 $\mathcal{C}_1$ 和 $\mathcal{C}_2$ 为两个微簇，那么这两个微簇形成的宏簇的簇特征矢量可以通过下式计算得到：

$$
\overline{CFC(\mathcal{C}_1 \cup \mathcal{C}_2)} = \overline{CFC(\mathcal{C}_1)} + \overline{CFC(\mathcal{C}_2)}
$$


**性质 2：** 令 $\mathcal{C}_1$ 和 $\mathcal{C}_2$ 为两个微簇，并且有 $\mathcal{C}_1 \supseteq \mathcal{C}_2$, 那么有下式成立：

$$
\overline{CFC(\mathcal{C}_1 - \mathcal{C}_2)} = \overline{CFC(\mathcal{C}_1)} - \overline{CFC(\mathcal{C}_2)}
$$

第二个性质用来得到某个时间窗口内的微簇信息。比如在 $t_c$ 时刻，用户需要得到过去 $h$ 时间段内的微簇信息。那么算法可以首先找到离 $t_c - h$  最近的时刻 $t_c -h'$ 的快照， 让我们记该时刻的微簇集合为 $\mathcal{S}(t_c - h')$，$t_c$ 时刻的微簇集合为 $\mathcal{S}(t_c)$。因为在微簇合并的时候，我们记录了被合并微簇的 ID 信息。所以对 $\mathcal{S}(t_c)$ 内每一个微簇，我们可以通过 ID （列表）信息在 $\mathcal{S}(t_c - h')$ 内找到对应的微簇。并将  $\mathcal{S}(t_c - h')$ 内对应的簇特征矢量从  $\mathcal{S}(t_c)$ 的簇特征适量中减除，得到 $t_c-h'$ 到 $t_c$ 这段时间内形成的微簇集合 $\mathcal{N}(t_c, h')$。

然后，我们可以利用修改的 k-means 算法对 $\mathcal{N}(t_c, h')$ 包含的微簇进行更高层次的聚类。聚类时，每一个微簇都被当作一个伪数据点对待（pseudo-point）。伪点的权重为其中包含的流数据点的个数。

1. 聚类开始时，根据每个伪数据点（微簇）的权重选取 $k$ 个伪点作为初始宏簇的中心。

2. 对每一个伪数据点，其离一个宏簇的距离为该伪点的中心点到宏簇中心的距离。

3. 更新宏簇中心时，新的宏簇中心为其包含的所有伪点的加权中心点。


# 簇的演化分析

在很多的应用中，我们期望分析簇是如何演化的，比如考虑两个时刻 $t_1$ 和 $t_2$，$t_2 > t_1$, 我们期望分析 $(t_1-h, t_1)$ 和  $(t_2-h, t_2)$  时间段内的簇有何不同。我们需要首先分别计算这两个时间段内形成的微簇集合 $\mathcal{N}(t_1, h)$ 和 $\mathcal{N}(t_2, h)$， 并将 $\mathcal{N}(t_1, h) \cup \mathcal{N}(t_2, h)$ 包含的微簇分为 3 类：

1. $\mathcal{N}(t_2, h)$ 中某个微簇的 ID 列表中的所有 ID 均不包含在 $\mathcal{N}(t_1, h)$ 的任何簇中。这表示该簇是在 $t_1 --- t_2$ 之间形成的，记为 $\mathcal{M}^{added}(t1, t2)$。

2. $\mathcal{N}(t_1, h)$ 中某个微簇的 ID 列表中的所有 ID 均不包含在 $\mathcal{N}(t_2, h)$ 的任何簇中。这表示该簇在 $t_1 --- t_2$ 之间被删除了，记为 $\mathcal{M}^{deleted}(t1, t2)$。

3. $\mathcal{N}(t_2, h)$ 中某个微簇的 ID 列表中的所有或者一部分 ID 包含在 $\mathcal{N}(t_1, h)$ 中对应簇的 ID 列表内。这表示该簇在 $t_1$ 之前被创建，并且在 $t_1 --- t_2$ 之间被更新，记为 $\mathcal{M}^{retained}(t1, t2)$。


宏聚类算法将分别对这三类微簇聚类得到更高层次的宏簇。使用 $\mathcal{M}^{added}(t1, t2)$ 和 $\mathcal{M}^{deleted}(t1, t2)$ 得到的宏簇具有重要的意义，因为他们代表了数据流中剧烈变化的部分。$\mathcal{M}^{retained}(t1, t2)$ 包含的微簇代表了数据流中变化较小的部分。如果大部分微簇属于 $\mathcal{M}^{retained}(t1, t2)$， 那么证明数据流在这段时间内是相对稳定。

# Reference

1. C. C. Aggarwal, J. Han, J. Wang, and P. S. Yu, "[A Framework for Clustering Evolving Data Streams,](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.13.8650&rep=rep1&type=pdf)" in *Proceedings of the 29th International Conference on Very Large Data Bases*, **2003,** pp. 81-92.

2. [CluStream — A Framework for Clustering Evolving Data Streams](https://medium.com/@niruhan/clustream-a-framework-for-clustering-evolving-data-streams-b2f8b2d65ae), Niruhan Viswarupan

